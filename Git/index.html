<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>git</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="git">Git</h1>
<h3 id="-git">什么是Git</h3>
<blockquote>
<p>Git是目前世界上最流行的分布式版本控制系统。</p>
</blockquote>
<h3 id="-version-control-systems-">什么是版本控制（Version Control Systems）</h3>
<blockquote>
<p>这是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
这个系统可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态。
使用版本控制查看一个文件的变动历史，类似与下面的样子:</br></p>
</blockquote>
<table>
<thead>
<tr>
<th>版本</th>
<th>用户</th>
<th>记录</th>
<th>备注</th>
<th>日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小三</td>
<td>删除信息</td>
<td>删除今日消费记录</td>
<td>1/12 08:00</td>
</tr>
<tr>
<td>2</td>
<td>王五</td>
<td>填写信息</td>
<td>填写今日收入</td>
<td>2/14 14:30</td>
</tr>
<tr>
<td>3</td>
<td>小三</td>
<td>填写信息</td>
<td>填写旅游计划</td>
<td>5/17 18:10</td>
</tr>
</tbody>
</table>
<p></br>从此我们就结束了手动管理多个版本的史前时代。</p>
<h4 id="-">版本控制系统的分类</h4>
<blockquote>
<p>实现版本控制的软件有很多种类，大致可以分为本地版本控制系统、集中式版本控制系统、分布式版本控制系统。</p>
</blockquote>
<h6 id="-">本地式版本控制系统</h6>
<blockquote>
<p>借助软件我们可以记录下文件的每一次修改，文件被修改后，
我们通过版本控制系统（软件）便可以非常方便的恢复到任意版本。
这种类型的版本控制系统，功能比较单一，比如很难实现多人协同开发，
有些文件编辑工具自身会带有本地版本控制系统，比如WebStorm中的Local History。
</br><img src="./local_version.png" alt="本地式"></p>
</blockquote>
<h6 id="-">集中式版本控制系统</h6>
<blockquote>
<p>实际开发环境，一个项目通常是由多人协作共同完成的，
如何让在不同终端上的开发者协同工作成了亟待解决的问题。集中式版本控制系统便应运而生了。
它通过单一的集中管理的服务器，保存所有文件的修订版本，
协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN。
集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，
可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊，
另外集中管理的服务器一旦出现故障，将会存在数据（版本）丢失的风险。
</br><img src="./img/git/central_version.png" alt="集中式"></p>
</blockquote>
<h6 id="-">分布式版本控制系统</h6>
<blockquote>
<p>分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，
这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p>
</blockquote>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，
因为可能你们俩不在一个局域网内，两台电脑互相访问不了，
也可能今天你的同事病了，他的电脑压根没有开机。
因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，
但这个服务器的作用仅仅是用来方便“交换”大家的修改，
没有它大家也一样干活，只是交换修改不方便而已。
</br><img src="./img/git/distributed_version.png" alt="分布式"></p>
<h6 id="-">集中式和分布式比较</h6>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，
因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。
而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<h3 id="git-">Git这么牛逼的工具是如何诞生的</h3>
<blockquote>
<p>很多人都知道，Linus在1991年创建了开源的Linux，
从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p>
</blockquote>
<p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，
这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，
然后由Linus本人通过手工方式合并代码！</p>
<p>当时已经存在一些版本控制系统了，比如CVS和SVN，但是Linus坚定地反对使用它们，
这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。
有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p>
<p>不过，到了2002年，Linux系统已经发展了十年了，
代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，
于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，
授权Linux社区免费使用这个版本控制系统。</p>
<p>后来，因为总总原因BitMover公司收回了Linux社区的免费使用权。
Linus心里不爽就花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！
一个月之内，Linux系统的源码已经由Git管理了！</p>
<h3 id="git-4-">Git的4种文件状态</h3>
<p>Git在管理我们文件的时候，给文件定义了4种状态，
分别为未追踪（untracked）、已提交（committed）、已修改（modified）和已暂存（staged）。
由此引入 Git 项目的3个工作区域的概念：工作目录、暂存区域以及版本仓库。</p>
<p>工作目录: 即我们编写代码的工作目录。
暂存区域：工作目录的临时备份。
版本仓库：所有文件版本的永久备份。</p>
<h3 id="git-">Git基本工作流</h3>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。</li>
</ol>
<h3 id="git-">Git基本使用</h3>
<h6 id="1-">1、预备工作</h6>
<ul>
<li>新建一个目录该目录内右键 &gt; Git Bash Here</li>
</ul>
<h6 id="2-">2、配置用户</h6>
<ul>
<li>配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为，
如某某某于2016-08-24解决了一个bug。--global代表全局配置，以后创建的所有仓库都默认使用该配置<ul>
<li>git config --global user.name 自己的名字</li>
<li>git config --global user.email 自己的邮箱</li>
</ul>
</li>
<li>查看配置信息<ul>
<li>git config --list</li>
</ul>
</li>
</ul>
<h6 id="3-">3、初始化仓库</h6>
<ul>
<li>我们如果想要利用git进行版本控制，需要将现有项目初始化为一个仓库，
或者将一个已有的使用git进行版本控制的仓库克隆到本地。<ul>
<li>git init</li>
</ul>
</li>
<li>查看当前项目目录是否创建了一个名为.git的隐藏目录，
这个目录包含了暂存区和仓库两个区域，有了这个隐藏目录就可以使用git来管理项目了。<ul>
<li>ls -al</li>
</ul>
</li>
</ul>
<h6 id="4-">4、查看文件状态</h6>
<ul>
<li>初始化仓库后便可以进行开发了，进入到刚刚创建好并初始为仓库的目录，
添加我们开发需要的文件，然后查看文件的状态（未追踪untracked）。<ul>
<li>mkdir css js</li>
<li>echo 页面结构 &gt;&gt; index.html</li>
<li>echo 样式编写 &gt;&gt; css/index.css</li>
<li>git status</li>
</ul>
</li>
</ul>
<h6 id="5-">5、添加文件到暂存区</h6>
<ul>
<li>经过一定的编写，要对文件进行版本管理，需要先把新建的文件添加到暂存区。
然后查看文件状态，放到暂存区的文件被标记成了绿色，等待提交。
注：颜色是工具给添加的，目的是增加可读性并不是git统一的。<ul>
<li>git add 文件1 文件2 ..</li>
<li>git status</li>
</ul>
</li>
<li>文件太多可以使用*或者-A选项代表所有<ul>
<li>git add [* | -A]</li>
</ul>
</li>
</ul>
<h6 id="6-">6、撤销更改</h6>
<ul>
<li>继续我们的开发，然后查看仓库状态，
修改的文件被标记为了红色，说明index.html被再次修改了。<ul>
<li>echo 页面结构2 &gt;&gt; index.html</li>
<li>git status</li>
</ul>
</li>
<li>提交修改，然后继续开发，假设新编写的代码有问题，
想要回到之前状态，将暂存的文件还原到工作区。<ul>
<li>echo 页面结构3 &gt;&gt; index.html</li>
<li>cat index.html</li>
<li>git checkout [--] index.html</li>
<li>cat index.html</li>
</ul>
</li>
</ul>
<h6 id="7-">7、修改比较</h6>
<ul>
<li>继续我们的开发，开发一段时间后，想和上一次暂存的文件进行比较，
确认一下具体都对哪些地方做了修改，确认修改无误后添加到暂存区。<ul>
<li>echo 新版页面结构3 &gt;&gt; index.html</li>
<li>git diff index.html</li>
<li>git add .</li>
</ul>
</li>
</ul>
<h6 id="8-">8、提交文件</h6>
<ul>
<li>经过一个相对较长阶段开发或者一个功能开发完成了，
就可以提交到本地仓库了，永久保存了。
这时被标记成绿色的暂存区文件，全部提交到本地仓库存储。<ul>
<li>git status</li>
<li>git commit -m &#39;备注信息&#39;</li>
<li>git status</li>
</ul>
</li>
</ul>
<h6 id="9-">9、查看提交历史</h6>
<ul>
<li>反反复复开发了很多的功能了，查看一下提交的版本历史。
默认查看全部，如果比较多可以像vi快捷键那样上下翻页，q退出。
也可以任意指定查看的数量以及格式化输出。<ul>
<li>git log [--oneline] [数量]</li>
</ul>
</li>
</ul>
<h6 id="10-">10、新一轮开发</h6>
<ul>
<li>创建文件、修改文件</li>
<li>添加到暂存区</li>
<li>提交版本</li>
<li>查看提交历史</li>
</ul>
<h6 id="11-">11、版本回退</h6>
<ul>
<li>开发中需要可能随时发生变化，假设刚刚开发完毕的功能要舍弃，
重新开发新的功能，我们可以恢复到之前某一次的提交，
在那个基础上进行新的需求开发，然后查看版本历史，恢复了之前的某个时期。<ul>
<li>git log</li>
<li>git reset --hard 版本ID</li>
<li>git log</li>
</ul>
</li>
</ul>
<h6 id="12-">12、版本变化历史</h6>
<ul>
<li>也许有一天你想查阅之前所有的历史版本变化，
或者寻找某个已丢失的版本，该命令会对你有所帮助。<ul>
<li>git reflog</li>
</ul>
</li>
</ul>
<h3 id="-">分支</h3>
<blockquote>
<p>分支就像是对一个目录进行多次拷贝，一次拷贝看作是一个分支，
在不同的分支中进行不同的功能开发与修改，这样在不同功能开发时避免杂乱，
最终可以把多个子分支再合并到最初的主目录，这样也更符合团队开发流程。</p>
</blockquote>
<p>在我们的现实开发中，需求往往是五花八门的，同时开发多个需求的情况十分常见。
有时候突然冒出一个需求，可能要优先完成，但是我们已经正在专注开发一个功能，
要终止当前开发，转入新需求开发，分支就派上了用场。
分支可以让我们并行开发多个不同的功能，在开发时互干涉与影响，
直到开发完毕后，再一次性合并到原来的分支上。
分支在团队合作中应用甚广，即方便安全，又不影响别人工作。</p>
<h6 id="1-">1、创建分支</h6>
<ul>
<li>当我们在初始化仓库的时候（实际上是产生第1次提交时），
Git会默认帮我们创建一个master的分支，所以之前我们的操作都是在该分支下完成的。
该分支通常被作为项目的主干使用，基于它我们可以创建各种子孙分支，
子分支会继承父分支当前的版本记录，现在我们就创建一个子分支，进行我们新的开发任务。<ul>
<li>git branch 分支名称</li>
</ul>
</li>
</ul>
<h6 id="2-">2、切换分支</h6>
<ul>
<li>刚才只是创建了一个新的分支，我们还需要切换到该分支。<ul>
<li>git checkout 分支名称</li>
</ul>
</li>
</ul>
<h6 id="3-">3、创建新分支</h6>
<ul>
<li>像之前在master分支那样，使用各种命令对文件进行操作，
然后出现一个比较急的新需求需要我们马上切入，
可以对当前分支的文件进行提交，然后创建新的分支进行开发。<ul>
<li>echo &#39;console.log(&#39;xx分支未完成&#39;)&#39; &gt;&gt; js/main.js</li>
<li>git commit -am &#39;切入紧急需要开发，暂存提交&#39;</li>
<li>git checkout master</li>
<li>git branch 新分支名称</li>
</ul>
</li>
</ul>
<h6 id="4-">4、分支合并</h6>
<ul>
<li>紧急任务开发完毕后，进行提交。
测试无误后，把该功能的代码合并到master主分支上。
查看文件是否合并成功，然后查看版本历史里多了之前分支上的提交记录。<ul>
<li>echo &#39;console.log(&#39;紧急新需求&#39;)&#39; &gt;&gt; js/main.js</li>
<li>git commit -am &#39;完成xx紧急任务&#39;</li>
<li>git checkout master</li>
<li>git merge 新分支名称</li>
<li>cat js/main.js</li>
<li>git log --oneline</li>
</ul>
</li>
</ul>
<h6 id="5-">5、删除分支</h6>
<ul>
<li>子分支合并到父分支后，已经没有用处了，可以删除掉。
然后可以切换到都其他分支，或者创建新的分支继续开发。<ul>
<li>git branch -d 新分支名称</li>
<li>git branch</li>
</ul>
</li>
</ul>
<h6 id="6-">6、冲突解决</h6>
<ul>
<li>到目前为止，我们基于master主分支创建了两个分支，
其中一个分支已经开发完毕，并且对一些文件进行了修改，
现在进入到另一个分支进行开发，可能也会对相同的文件进行修改。<ul>
<li>git checkout 分支名称 </li>
<li>echo &#39;console.log(&#39;完成&#39;)&#39; &gt;&gt; js/main.js</li>
<li>git commit -am &#39;xx分支继续完成未完成任务&#39;</li>
</ul>
</li>
<li>这样，将来master在并入该分支时，某些文件就会不同修改造成的冲突。
我们需要手动对存在冲突的文件进行编辑，然后重新添加与提交。
查看版本历史，分支的版本已经融入，此时该分支也可以被删除了。<ul>
<li>git checkout master</li>
<li>git merge 分支名称</li>
<li>vi js/main.js</li>
<li>git commit -am &#39;解决xx分支冲突&#39;</li>
<li>git log --oneline</li>
<li>git branch -d 分支名称</li>
</ul>
</li>
</ul>
<h3 id="-">远程仓库</h3>
<p>通过上面学习我们可以很好的管理本地版本控制了，
可是如果我们下班回到家里突然来了灵感觉得有部分代码可以优化，
如果能接着公司电脑上的代码继续写该有多好呀！
另一种情形，假设项目比较大，不同的功能模块由不同的开发人员完成，
不同模块儿之间又难免会依赖关系，这时如果我们的代码互相合并（融合）该有多好呀！
所有模块开发完毕后，需要整合到一起，要能做到准确无误该有多好呀！
借助一个远程仓库，大家可以共享代码、历史版本等数据，便可以解决以上遇到的所有问题。</p>
<h6 id="1-">1、创建远程仓库</h6>
<ul>
<li>Git要求共享仓库是一个以.git结尾的目录，创建该目录。
然后进入目录运行初始化命令，注意--bare参数。
该方式创建的仓库称为裸仓库，即没有工作区，裸露暂存区与版本区的仓库。<ul>
<li>mkdir remote_dir.git</li>
<li>cd remote_dir.git</li>
<li>git init --bare</li>
<li>ls -l</li>
</ul>
</li>
</ul>
<h6 id="2-">2、基于远程仓库创建本地仓库</h6>
<ul>
<li>新创建一个目录，然后进入该目录，基于远程仓库创建本地仓库。
clone操作与init操作一样，一个仓库只需运行一次即可。<ul>
<li>git clone ../remote_dir.git .</li>
</ul>
</li>
</ul>
<h6 id="3-">3、本地仓库向远程仓库推送内容</h6>
<ul>
<li>在本地仓库进行文件添加与修改，并提交到版本库。
然后把本地内容推送到远程仓库进行备份与共享。<ul>
<li>echo &#39;项目创建&#39; &gt;&gt; index.html</li>
<li>git add index.html</li>
<li>git commit -m &#39;项目创建&#39;</li>
<li>git push ../remote_dir.git master</li>
</ul>
</li>
</ul>
<h6 id="4-">4、创建第二个本地仓库</h6>
<ul>
<li>创建第二个同级别的目录，模拟另外一个开发者，然后基于远程仓库创建本地仓库。
创建好后，查看仓库内容与历史版本。<ul>
<li>git clone ../remote_dir.git master</li>
<li>git log</li>
<li>ls</li>
</ul>
</li>
</ul>
<h6 id="5-2-">5、仓库2推送内容到远程</h6>
<ul>
<li>第二个仓库进行自己的开发工作，然后提交到远程仓库。<ul>
<li>mkdir css</li>
<li>echo &#39;body{padding:0;margin:0;}&#39; &gt;&gt; css/main.css</li>
<li>git add css/main.css</li>
<li>git commit -m &#39;初始化样式&#39;</li>
<li>git push ../remote_dir.git master</li>
</ul>
</li>
</ul>
<h6 id="6-1-">6、仓库1获取远程最新内容</h6>
<ul>
<li>切换到第二个仓库，获取最新的远程仓库内容，查看文件内容与历史版本。
奇迹似乎发生了，我们轻松的将仓库2里的内容，通过远程仓库共享给了仓库1。<ul>
<li>git pull ../remote_dir.git master</li>
<li>ls -l</li>
<li>git log</li>
</ul>
</li>
</ul>
<h3 id="github">gitHub</h3>
<p>刚才我们只是在本地模拟了远程仓库的能力。但真正开发时我们是不可能把远程仓库建在我们本地的。
如果我们熟悉服务器的话，完全可以将上述的步骤在我们的远程服务器上进行操作，
然后再做一些登录权限的设置，就可非常完美的搭建一个git远程仓库服务器了。
不过已经有第三方机构开发出了Web版的仓库管理程序，通过Web界面形式管理仓库。
gitHub就扮演了这样一个角色借助，它的名气大家可以自行搜索查阅，在gitHub我们可以免费并且很容易的创建远程仓库。
同时GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<h6 id="1-">1、账号注册</h6>
<ul>
<li><a href="https://github.com/">gitHub</a> 自行注册。</li>
</ul>
<h6 id="2-">2、创建远程仓库</h6>
<ul>
<li>点击头像左边的“+”号，选择New repository<ul>
<li><br/><img src="./img/github/info.png" alt="资料填写"></li>
<li><br/><img src="./img/github/success.png" alt="成功界面"></li>
</ul>
</li>
</ul>
<h6 id="3-">3、本地仓库关联</h6>
<ul>
<li>进入本地一个已经初始化过并存在历史版本的仓库。
然后给远程仓库起个origin别名，成功后把本地master分支代码推送到远程仓库的master分支上。
推送时添加-u参数，在下次推送文件到时远程时，默认就推送到了master分支。<ul>
<li>git remote add origin github仓库地址</li>
<li>git push -u origin master</li>
</ul>
</li>
<li>如果本地使用一个新目录，那clone就可以了。
当我们通过clone创建本地仓库时，git会自动帮我们添加origin到对应的仓库地址。<ul>
<li>git clone git@github.com:xxx.git 目录</li>
</ul>
</li>
</ul>
<h6 id="4-">4、本地推送内容到远程</h6>
<ul>
<li>本地开发一个功能，推送到远程时，一般会先拉取一下远程最新内容，没有问题后再推送。<ul>
<li>git pull origin(远程地址别名) master(远程分支名)</li>
<li>git push origin(远程地址别名)</li>
</ul>
</li>
</ul>
<h6 id="5-">5、模拟另一个人共享你的代码</h6>
<ul>
<li>本地新建一个空目录，然后进入该目录，clone远程仓库。
验证当前仓库是否通过远程仓库获取到了另一个本地仓库的内容。<ul>
<li>git clone git@github.com:xxx.git 目录</li>
<li>git log --oneline</li>
<li>ls -l</li>
</ul>
</li>
</ul>
<h6 id="6-">6、两个本地仓库借用远程仓库协作</h6>
<ul>
<li>在本地任意一个仓库进行代码编写和提交，然后push到远程，
然后另一个本地仓库尝试pull获取。</li>
</ul>
<h3 id="ssh">SSH</h3>
<blockquote>
<p>SSH为建立在应用层基础上的安全协议，
SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。
利用SSH协议可以有效防止远程管理过程中的信息泄露问题。
基于SSH协议存在多种实现，既有商业实现，也有开源实现，git默认支持SSH协议的用户认证与数据传送。</p>
</blockquote>
<h6 id="ssh-">SSH数据传输时的加密方式</h6>
<ul>
<li>常见有两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者。</li>
<li>对称加密算法在加密和解密时使用的是同一个密钥；</li>
<li>而非对称加密算法需要两个密钥来进行加密和解密，</li>
<li>这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。</li>
<li>使用公钥加密的数据，只有私钥可以解密；使用私钥加密的数据，只有公钥可以解密。</li>
</ul>
<h6 id="-github-">配置github公钥</h6>
<ul>
<li>运行命令，一顿回车，最终会在当前用户目录下生成一个.ssh的文件夹；
进入会看到里面含有两个文件，id_rsa存储密钥，id_rsa.pub存储公钥。<ul>
<li>ssh-keygen -t rsa</li>
</ul>
</li>
<li>进入gitHub的settings界面<ul>
<li><br/><img src="./img/github/settings.png" alt="setting入口"></li>
</ul>
</li>
<li>切到SSH keys的选项，创建ssh key，并把id_rsa.pub里存储的公钥复制到文本框，
书写一个标题，然后添加保存。<ul>
<li><br/><img src="./img/github/ssh_key.png" alt="ssh key"></li>
</ul>
</li>
<li>使用ssh连接github，查看是否出现你在github上注册的用户名和successful的提示。
如果出现，证明配置成功，尝试使用ssh的仓库地址进行clone，然后免密推送。<ul>
<li>ssh git@github.com</li>
</ul>
</li>
</ul>
<h6 id="gitlab-">gitLab了解</h6>
<ul>
<li>我们发现通过gitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，
自已公司的代码当然不能公开了，可是私有仓库又是需要交“保护费”的，
无耐国人还是比较喜欢免费的，网络界总是有很多雷峰的，比如gitLab!!!</li>
<li>gitLab也是一个可以通过Web界面管理仓库的网站程序，
我们可以把它架设到公司自已的服务器上，实现仓库私有化，
这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。</li>
</ul>
<h3 id="-">常用命令汇总</h3>
<ul>
<li>git config配置本地仓库<ul>
<li>常用git config --global user.name、git config --global user.email</li>
<li>git config --list查看配置详情</li>
</ul>
</li>
<li>git init 初始一个仓库<ul>
<li>添加--bare可以初始化一个共享（裸）仓库</li>
</ul>
</li>
<li>git status 可以查看当前仓库的状态</li>
<li>git add “文件” 将工作区中的文件添加到暂存区中<ul>
<li>其中file可是一个单独的文件，也可以是一个目录、“*”、-A</li>
</ul>
</li>
<li>git commit -m &#39;备注信息&#39; 将暂存区的文件，提交到本地仓库</li>
<li>git log 可以查看本地仓库的提交历史</li>
<li>git reflog 可以查看版本的变化历史</li>
<li>git branch 查看分支<ul>
<li>git branch “分支名称” 创建一个新的分支</li>
<li>git branch -d “分支名称” 删除分支</li>
</ul>
</li>
<li>git checkout “分支名称” 切换分支<ul>
<li>git checkout -b deeveloper 他健并切到developer分支</li>
</ul>
</li>
<li>git merge “分支名称” 合并分支</li>
<li>git clone “仓库地址” 获取已有仓库的副本</li>
<li>git push origin “本地分支名称:远程分支名称” 将本地分支推送至远程仓库<ul>
<li>git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix</li>
<li>git push origin hotfix:newfeature</li>
</ul>
</li>
<li>git remote 可以查看已添加的远程主机<ul>
<li>git remote add “主机名称” “远程仓库地址” 添加远程主机，即给远程主机起个别名</li>
<li>git remote show “主机名称” 可以查看远程主机的信息</li>
</ul>
</li>
</ul>
<h3 id="-">其他</h3>
<p>熟悉掌握以上操作，基本上是可以满足日常开的需要的，
但是在解决一些特殊问题时，就又需要我们能够掌握更多的命令。</p>
<h6 id="-">文件忽略</h6>
<p>在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里。</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>